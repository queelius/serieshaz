[{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"build-and-test-commands","dir":"","previous_headings":"","what":"Build and Test Commands","title":"CLAUDE.md","text":"","code":"# Install dependencies (from GitHub remotes) Rscript -e 'remotes::install_deps(dependencies = TRUE)'  # Build and check R CMD build . R CMD check serieshaz_*.tar.gz  # Run all tests Rscript -e 'testthat::test_dir(\"tests/testthat\")'  # Run a single test file Rscript -e 'testthat::test_file(\"tests/testthat/test-constructor.R\")'  # Run tests matching a pattern Rscript -e 'testthat::test_dir(\"tests/testthat\", filter = \"composition\")'  # Regenerate NAMESPACE and man/ pages (after roxygen changes) Rscript -e 'roxygen2::roxygenise()'  # Test coverage Rscript -e 'covr::package_coverage()'"},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"architecture","dir":"","previous_headings":"","what":"Architecture","title":"CLAUDE.md","text":"package composes multiple dfr_dist objects (flexhaz package) series system distribution. series system fails component fails, system hazard sum component hazards: h_sys(t) = sum_j h_j(t).","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"class-hierarchy","dir":"","previous_headings":"Architecture","what":"Class Hierarchy","title":"CLAUDE.md","text":"dfr_dist_series inherits dfr_dist inherits likelihood_model -> univariate_dist -> dist. inheritance chain means existing methods (hazard, survival, CDF, density, sampling, log-likelihood, MLE fitting) work automatically series systems without reimplementation.","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"three-dependency-packages-all-from-githubqueelius","dir":"","previous_headings":"Architecture","what":"Three Dependency Packages (all from github::queelius/)","title":"CLAUDE.md","text":"algebraic.dist: Base distribution generics (hazard, surv, cdf, inv_cdf, sampler, params) likelihood.model: Statistical inference generics (loglik, score, hess_loglik, assumptions, fit) flexhaz: Dynamic failure rate distributions (dfr_dist constructor, named distributions like dfr_exponential, dfr_weibull, dfr_gompertz, dfr_loglogistic)","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"parameter-layout-system","dir":"","previous_headings":"Architecture","what":"Parameter Layout System","title":"CLAUDE.md","text":"Parameters across components stored single concatenated vector. $layout field maps global indices per-component indices. example, Weibull(shape, scale) + Exponential(rate): layout = list(1:2, 3), global parameter vector c(shape1, scale1, rate2) gets sliced par[1:2] component 1 par[3] component 2. design enables standard optimizers work flat parameter vector series system distributes parameters correct components.","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"closure-based-design","dir":"","previous_headings":"Architecture","what":"Closure-Based Design","title":"CLAUDE.md","text":"distribution functions (hazard, surv, cdf, etc.) return closures — function(t, par = NULL, ...) — values. system-level closures internally loop components, slice parameter vector via layout, sum hazards. components provide cum_haz_rate, series system gets analytical cumulative hazard; otherwise falls back numerical integration. Score Hessian always use numDeriv fallback.","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"source-file-organization","dir":"","previous_headings":"Architecture","what":"Source File Organization","title":"CLAUDE.md","text":"R/dfr_dist_series.R: Constructor (dfr_dist_series), type predicate, print method, assumptions R/methods.R: S3 method implementations (ncomponents, component, param_layout, component_hazard, sample_components) R/generic_functions.R: Generic function definitions series-specific generics R/reexports.R: Re-exports dependency packages","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"testing-patterns","dir":"","previous_headings":"Architecture","what":"Testing Patterns","title":"CLAUDE.md","text":"Test fixtures tests/testthat/helper-fixtures.R. gold-standard verification strategy : 3 exponential components rates (r1, r2, r3) must behave identically single exponential rate (r1 + r2 + r3). Tests also verify S_sys(t) = product S_j(t) Weibull series, min(component samples) follows system distribution.","code":""},{"path":"https://queelius.github.io/serieshaz/CLAUDE.html","id":"key-identifiability-constraint","dir":"","previous_headings":"Architecture","what":"Key Identifiability Constraint","title":"CLAUDE.md","text":"Exponential series systems identifiable system-level data alone — sum rates identifiable. fitting tests account checking sum(coef(result)) rather individual parameters.","code":""},{"path":"https://queelius.github.io/serieshaz/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License v3.0 or later","title":"GNU General Public License v3.0 or later","text":"Copyright (c) 2024 Alexander Towell program free software: can redistribute /modify terms GNU General Public License published Free Software Foundation, either version 3 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. received copy GNU General Public License along program. , see https://www.gnu.org/licenses/.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"mixed-component-types","dir":"Articles","previous_headings":"","what":"Mixed Component Types","title":"Advanced Series System Composition","text":"Real systems often failure modes different aging characteristics. Consider server : Hard disk — Weibull wear-(increasing hazard) Memory — exponential random failures (constant hazard) Power supply — Gompertz degradation (accelerating hazard)","code":"library(serieshaz)  disk <- dfr_weibull(shape = 2, scale = 500) mem  <- dfr_exponential(0.001) psu  <- dfr_gompertz(a = 0.0001, b = 0.02)  server <- dfr_dist_series(list(disk, mem, psu))"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"hazard-decomposition","dir":"Articles","previous_headings":"Mixed Component Types","what":"Hazard Decomposition","title":"Advanced Series System Composition","text":"component contributes differently system risk time: t=50t = 50, constant memory hazard (0.0010.001) largest contributor — Weibull (0.00040.0004) Gompertz (0.00030.0003) still small. Memory remains dominant t=100t = 100, Gompertz’s exponential acceleration (∝ebt\\propto e^{bt}) overtakes around t=125–150t = 125\\text{--}150. t=250t = 250, Gompertz contributes 0.0150.015 vs memory’s constant 0.0010.001, dominating system risk. crossover pattern characteristic mixed-type series systems: failure mode “era” dominance.","code":"h_disk <- component_hazard(server, 1) h_mem  <- component_hazard(server, 2) h_psu  <- component_hazard(server, 3) h_sys  <- hazard(server)  t_grid <- seq(10, 300, by = 10) cat(\"Time | Disk     | Memory   | PSU      | System\\n\") #> Time | Disk     | Memory   | PSU      | System cat(\"-----|----------|----------|----------|--------\\n\") #> -----|----------|----------|----------|-------- for (t0 in c(50, 100, 150, 200, 250)) {     cat(sprintf(\"%4d | %.6f | %.6f | %.6f | %.6f\\n\",                 t0, h_disk(t0), h_mem(t0), h_psu(t0), h_sys(t0))) } #>   50 | 0.000400 | 0.001000 | 0.000272 | 0.001672 #>  100 | 0.000800 | 0.001000 | 0.000739 | 0.002539 #>  150 | 0.001200 | 0.001000 | 0.002009 | 0.004209 #>  200 | 0.001600 | 0.001000 | 0.005460 | 0.008060 #>  250 | 0.002000 | 0.001000 | 0.014841 | 0.017841"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"nested-series-systems","dir":"Articles","previous_headings":"","what":"Nested Series Systems","title":"Advanced Series System Composition","text":"Since dfr_dist_series dfr_dist, can used component another series system. enables hierarchical modeling.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"example-subsystem-composition","dir":"Articles","previous_headings":"Nested Series Systems","what":"Example: Subsystem Composition","title":"Advanced Series System Composition","text":"","code":"# CPU subsystem: two exponential failure modes cpu <- dfr_dist_series(list(     dfr_exponential(0.001),  # thermal failure     dfr_exponential(0.0005)  # electrical failure ))  # Storage subsystem: Weibull wear + exponential shock storage <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 1000),     dfr_exponential(0.0002) ))  # Full system: CPU + storage + power supply full <- dfr_dist_series(list(     cpu,     storage,     dfr_gompertz(a = 0.0001, b = 0.01) ))  cat(\"Full system components:\", ncomponents(full), \"\\n\") #> Full system components: 3 cat(\"Total parameters:\", length(params(full)), \"\\n\") #> Total parameters: 7"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"verifying-nested-hazard","dir":"Articles","previous_headings":"Nested Series Systems","what":"Verifying Nested Hazard","title":"Advanced Series System Composition","text":"nested system’s hazard equal sum leaf-component hazards:","code":"h_full <- hazard(full)  # Manually sum all leaf hazards h_cpu1 <- component_hazard(cpu, 1) h_cpu2 <- component_hazard(cpu, 2) h_stor1 <- component_hazard(storage, 1) h_stor2 <- component_hazard(storage, 2) h_psu <- component_hazard(full, 3)  t0 <- 100 nested_sum <- h_cpu1(t0) + h_cpu2(t0) + h_stor1(t0) + h_stor2(t0) + h_psu(t0) system_h <- h_full(t0)  cat(sprintf(\"Sum of leaf hazards: %.8f\\n\", nested_sum)) #> Sum of leaf hazards: 0.00217183 cat(sprintf(\"System hazard:       %.8f\\n\", system_h)) #> System hazard:       0.00217183 cat(sprintf(\"Difference:          %.2e\\n\", abs(nested_sum - system_h))) #> Difference:          4.34e-19"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"custom-components","dir":"Articles","previous_headings":"","what":"Custom Components","title":"Advanced Series System Composition","text":"dfr_dist() constructor lets define components arbitrary hazard functions. can used series systems alongside built-distributions.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"bathtub-curve-component","dir":"Articles","previous_headings":"Custom Components","what":"Bathtub Curve Component","title":"Advanced Series System Composition","text":"bathtub-shaped hazard (high early, low middle, high late) can model products infant mortality wear-: bathtub shape visible: high hazard t=1t = 1 (≈0.50\\approx 0.50, dominated infant mortality term /tba/t^b), dropping minimum t=10t = 10 (≈0.17\\approx 0.17), rising steeply wear-term c⋅tdc \\cdot t^d kicks (≈1.05\\approx 1.05 t=100t = 100, ≈4.04\\approx 4.04 t=200t = 200). constant exponential shock (0.0010.001) adds negligible baseline floor.","code":"# Bathtub: h(t) = a/t^b + c*t^d  (infant mortality + wear-out) bathtub <- dfr_dist(     rate = function(t, par, ...) {         a <- par[1]; b <- par[2]; c <- par[3]; d <- par[4]         a * t^(-b) + c * t^d     },     par = c(0.5, 0.5, 0.0001, 2) )  # Series system with bathtub + exponential random shock sys <- dfr_dist_series(list(bathtub, dfr_exponential(0.001)))  h_sys <- hazard(sys) for (t0 in c(1, 10, 50, 100, 200)) {     cat(sprintf(\"t=%3d: h_sys = %.6f\\n\", t0, h_sys(t0))) } #> t=  1: h_sys = 0.501100 #> t= 10: h_sys = 0.169114 #> t= 50: h_sys = 0.321711 #> t=100: h_sys = 1.051000 #> t=200: h_sys = 4.036355"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"effect-on-cumulative-hazard","dir":"Articles","previous_headings":"Custom Components","what":"Effect on Cumulative Hazard","title":"Advanced Series System Composition","text":"custom component doesn’t provide cum_haz_rate, series system falls back numerical integration: bathtub parameterization, high infant mortality (=0.5a = 0.5, b=0.5b = 0.5) drives cumulative hazard high survival drops 5% t=10t = 10. practice, calibrate bathtub parameters match observed failure patterns. numerical integration fallback handles steep hazard functions correctly, just slowly analytical path.","code":"cat(\"Analytical cum_haz available:\", !is.null(sys$cum_haz_rate), \"\\n\") #> Analytical cum_haz available: FALSE  # The system still computes survival correctly via numerical integration S <- surv(sys) for (t0 in c(10, 50, 100)) {     cat(sprintf(\"t=%3d: S(t) = %.6f\\n\", t0, S(t0))) } #> t= 10: S(t) = 0.040534 #> t= 50: S(t) = 0.000013 #> t=100: S(t) = 0.000000"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"failure-attribution","dir":"Articles","previous_headings":"","what":"Failure Attribution","title":"Advanced Series System Composition","text":"sample_components() generates component-level lifetimes, enabling identification component caused system failure.","code":"server <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 200),     # mechanical wear     dfr_exponential(0.005),            # random shock     dfr_gompertz(a = 0.0001, b = 0.02)       # degradation ))  set.seed(42) n <- 10000 mat <- sample_components(server, n = n)  # System lifetime = minimum across components t_sys <- apply(mat, 1, min)  # Identify the failing component for each observation failing <- apply(mat, 1, which.min)"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"attribution-proportions","dir":"Articles","previous_headings":"Failure Attribution","what":"Attribution Proportions","title":"Advanced Series System Composition","text":"","code":"props <- table(failing) / n names(props) <- c(\"Weibull (wear)\", \"Exp (shock)\", \"Gompertz (degrad.)\") cat(\"Failure attribution:\\n\") #> Failure attribution: print(round(props, 3)) #>     Weibull (wear)        Exp (shock) Gompertz (degrad.)  #>              0.376              0.512              0.112"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"attribution-by-time-window","dir":"Articles","previous_headings":"Failure Attribution","what":"Attribution by Time Window","title":"Advanced Series System Composition","text":"Failure causes change system’s lifetime:","code":"# Split into early, middle, and late failures breaks <- quantile(t_sys, probs = c(0, 1/3, 2/3, 1)) period <- cut(t_sys, breaks = breaks, labels = c(\"Early\", \"Middle\", \"Late\"),               include.lowest = TRUE)  cat(\"\\nAttribution by time period:\\n\") #>  #> Attribution by time period: for (p in levels(period)) {     idx <- which(period == p)     props_p <- table(factor(failing[idx], levels = 1:3)) / length(idx)     cat(sprintf(\"  %s (n=%d): Wear=%.1f%% Shock=%.1f%% Degrad=%.1f%%\\n\",                 p, length(idx),                 100 * props_p[1], 100 * props_p[2], 100 * props_p[3])) } #>   Early (n=3334): Wear=20.8% Shock=75.9% Degrad=3.2% #>   Middle (n=3333): Wear=44.7% Shock=48.9% Degrad=6.3% #>   Late (n=3333): Wear=47.3% Shock=28.7% Degrad=24.0%"},{"path":"https://queelius.github.io/serieshaz/articles/series-advanced.html","id":"parameter-sensitivity","dir":"Articles","previous_headings":"","what":"Parameter Sensitivity","title":"Advanced Series System Composition","text":"parameter layout enables systematic sensitivity analysis: vary one component’s parameters holding others fixed.","code":"server <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) ))  S_fn <- surv(server) base_par <- params(server)  # c(2, 100, 0.01) t0 <- 50  cat(\"Sensitivity of S(50) to Weibull scale parameter:\\n\") #> Sensitivity of S(50) to Weibull scale parameter: for (scale_val in c(50, 75, 100, 125, 150)) {     par_mod <- base_par     par_mod[2] <- scale_val  # layout tells us par[2] is Weibull scale     cat(sprintf(\"  scale = %3d: S(50) = %.4f\\n\", scale_val, S_fn(t0, par = par_mod))) } #>   scale =  50: S(50) = 0.2231 #>   scale =  75: S(50) = 0.3889 #>   scale = 100: S(50) = 0.4724 #>   scale = 125: S(50) = 0.5169 #>   scale = 150: S(50) = 0.5427  cat(\"\\nSensitivity of S(50) to exponential rate:\\n\") #>  #> Sensitivity of S(50) to exponential rate: for (rate_val in c(0.005, 0.01, 0.02, 0.05, 0.1)) {     par_mod <- base_par     par_mod[3] <- rate_val  # layout tells us par[3] is exp rate     cat(sprintf(\"  rate = %.3f: S(50) = %.4f\\n\", rate_val, S_fn(t0, par = par_mod))) } #>   rate = 0.005: S(50) = 0.6065 #>   rate = 0.010: S(50) = 0.4724 #>   rate = 0.020: S(50) = 0.2865 #>   rate = 0.050: S(50) = 0.0639 #>   rate = 0.100: S(50) = 0.0052"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Fitting Series Systems to Data","text":"practice, observe system-level failure data: time system failed (censored), often component caused failure. serieshaz package fits series system models data via maximum likelihood estimation (MLE).","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"data-format","dir":"Articles","previous_headings":"","what":"Data Format","title":"Fitting Series Systems to Data","text":"fitting functions expect data frame two columns: censoring indicator values : 1 — exact observation (system failed time t) 0 — right-censored (system still running time t) -1 — left-censored (system already failed time t)","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"step-1-define-the-system-model","dir":"Articles","previous_headings":"Basic Fitting Workflow","what":"Step 1: Define the System Model","title":"Fitting Series Systems to Data","text":"","code":"library(serieshaz)  # Hypothesize: system has two failure modes #   - Wear-out (Weibull) #   - Random shock (exponential) model <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) ))"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"step-2-simulate-training-data","dir":"Articles","previous_headings":"Basic Fitting Workflow","what":"Step 2: Simulate Training Data","title":"Fitting Series Systems to Data","text":"practice ’d real field data. simulate known parameters demonstrate workflow.","code":"set.seed(42) true_par <- c(2, 100, 0.01)  # shape, scale, rate  samp <- sampler(model) n <- 300 times <- samp(n, par = true_par) train <- data.frame(t = times, delta = rep(1L, n))  summary(train$t) #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #>   0.02386  21.45824  46.56538  53.75536  77.11423 193.31375"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"step-3-fit-the-model","dir":"Articles","previous_headings":"Basic Fitting Workflow","what":"Step 3: Fit the Model","title":"Fitting Series Systems to Data","text":"","code":"solver <- fit(model)  # Provide initial parameter guesses init_par <- c(1.5, 80, 0.02) result <- solver(train, par = init_par) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"step-4-extract-results","dir":"Articles","previous_headings":"Basic Fitting Workflow","what":"Step 4: Extract Results","title":"Fitting Series Systems to Data","text":"","code":"# Fitted parameters cat(\"True parameters:\", true_par, \"\\n\") #> True parameters: 2 100 0.01 cat(\"Fitted parameters:\", coef(result), \"\\n\") #> Fitted parameters: 2.47432 109.1372 0.01211101  # Log-likelihood at MLE cat(\"Log-likelihood:\", logLik(result), \"\\n\") #> Log-likelihood: -1475.163  # Variance-covariance matrix vcov(result) #>              [,1]         [,2]         [,3] #> [1,] 0.2503925591   4.37634657 7.702069e-04 #> [2,] 4.3763465699 139.44446132 1.998348e-02 #> [3,] 0.0007702069   0.01998348 4.079105e-06"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"initial-parameter-selection","dir":"Articles","previous_headings":"","what":"Initial Parameter Selection","title":"Fitting Series Systems to Data","text":"choice initial parameters can affect convergence. Strategies include: Domain knowledge: Use engineering estimates handbook values Simpler model first: Fit single exponential get rough rate, use starting point Multiple starts: Try several initial values keep best fit","code":"# Strategy: try a few initial guesses, keep the best init_guesses <- list(     c(1.5, 80,  0.02),     c(2.5, 120, 0.005),     c(1.0, 50,  0.05) )  best_ll <- -Inf best_result <- NULL for (init in init_guesses) {     res <- tryCatch(solver(train, par = init), error = function(e) NULL)     if (!is.null(res) && logLik(res) > best_ll) {         best_ll <- logLik(res)         best_result <- res     } } #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced cat(\"Best log-likelihood:\", best_ll, \"\\n\") #> Best log-likelihood: -1475.163 cat(\"Best parameters:\", coef(best_result), \"\\n\") #> Best parameters: 2.484501 109.2152 0.01213407"},{"path":[]},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"exponential-series-non-identifiable","dir":"Articles","previous_headings":"Identifiability","what":"Exponential Series: Non-Identifiable","title":"Fitting Series Systems to Data","text":"components exponential, sum rates identifiable system-level data. system hazard hsys(t)=∑jλjh_{sys}(t) = \\sum_j \\lambda_j constant, partition rates sums total produces likelihood. sum accurately estimated, individual rates meaningful.","code":"# True rates: 0.1, 0.2, 0.3 (sum = 0.6) true_rates <- c(0.1, 0.2, 0.3) exp_sys <- dfr_dist_series(lapply(true_rates, dfr_exponential))  set.seed(123) exp_samp <- sampler(exp_sys) exp_data <- data.frame(t = exp_samp(500), delta = rep(1L, 500))  exp_solver <- fit(exp_sys) exp_result <- exp_solver(exp_data, par = c(0.15, 0.25, 0.25)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced  cat(\"True sum of rates:\", sum(true_rates), \"\\n\") #> True sum of rates: 0.6 cat(\"Fitted sum of rates:\", sum(coef(exp_result)), \"\\n\") #> Fitted sum of rates: 0.6033517 cat(\"Individual rates (unreliable):\", coef(exp_result), \"\\n\") #> Individual rates (unreliable): 0.1344505 0.2344506 0.2344506"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"mixed-types-identifiable","dir":"Articles","previous_headings":"Identifiability","what":"Mixed Types: Identifiable","title":"Fitting Series Systems to Data","text":"components different distributional forms, system generally identifiable component shapes hazard differently.","code":"# Weibull (increasing hazard) + Exponential (constant hazard) mixed <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) ))  set.seed(42) mixed_samp <- sampler(mixed) mixed_data <- data.frame(t = mixed_samp(500), delta = rep(1L, 500))  mixed_solver <- fit(mixed) mixed_result <- mixed_solver(mixed_data, par = c(1.5, 80, 0.02)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced  cat(\"True:   shape=2.00, scale=100.0, rate=0.010\\n\") #> True:   shape=2.00, scale=100.0, rate=0.010 cat(sprintf(\"Fitted: shape=%.2f, scale=%.1f, rate=%.3f\\n\",             coef(mixed_result)[1], coef(mixed_result)[2], coef(mixed_result)[3])) #> Fitted: shape=2.49, scale=112.8, rate=0.013"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"handling-censored-data","dir":"Articles","previous_headings":"","what":"Handling Censored Data","title":"Fitting Series Systems to Data","text":"reliability studies, units removed test failing (right-censoring). MLE correctly accounts . censored uncensored fits recover parameters right ballpark. finite samples, MLE random variable — different random seeds censoring patterns can shift estimates either direction. censored fit uses less information (observations t=80t = 80 truncated), MLE correctly accounts censored likelihood contribution S(ti)S(t_i). general, heavier censoring increases standard errors, introduce systematic bias.","code":"set.seed(42) model <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) )) true_par <- c(2, 100, 0.01)  # Generate true failure times n <- 500 true_times <- sampler(model)(n, par = true_par)  # Right-censor at a fixed time horizon censor_time <- 80 observed_t <- pmin(true_times, censor_time) delta <- as.integer(true_times <= censor_time) cens_data <- data.frame(t = observed_t, delta = delta)  cat(\"Proportion censored:\", round(1 - mean(delta), 3), \"\\n\") #> Proportion censored: 0.232  # Fit with censored data solver <- fit(model) cens_result <- solver(cens_data, par = c(1.5, 80, 0.02)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced  cat(\"True parameters:    \", true_par, \"\\n\") #> True parameters:     2 100 0.01 cat(\"Fitted (censored):  \", round(coef(cens_result), 4), \"\\n\") #> Fitted (censored):   1.9106 105.7704 0.011 cat(\"Fitted (uncensored):\", round(coef(result), 4), \"\\n\") #> Fitted (uncensored): 2.4743 109.1372 0.0121"},{"path":[]},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"log-likelihood-comparison","dir":"Articles","previous_headings":"Model Diagnostics","what":"Log-Likelihood Comparison","title":"Fitting Series Systems to Data","text":"Compare competing models using log-likelihood, AIC, BIC:","code":"# Model 1: Weibull + Exponential (3 parameters) m1 <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) ))  # Model 2: Two Weibulls (4 parameters) m2 <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_weibull(shape = 1.5, scale = 200) ))  # Generate data from Model 1 set.seed(42) data_m1 <- data.frame(     t = sampler(m1)(300, par = c(2, 100, 0.01)),     delta = rep(1L, 300) )  r1 <- fit(m1)(data_m1, par = c(1.5, 80, 0.02)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced r2 <- fit(m2)(data_m1, par = c(1.5, 80, 1.2, 150)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced  k1 <- length(coef(r1)) k2 <- length(coef(r2)) ll1 <- logLik(r1) ll2 <- logLik(r2)  aic1 <- -2 * ll1 + 2 * k1 aic2 <- -2 * ll2 + 2 * k2  cat(sprintf(\"Model 1 (Weibull+Exp):    LL=%.2f, k=%d, AIC=%.2f\\n\", ll1, k1, aic1)) #> Model 1 (Weibull+Exp):    LL=-1475.16, k=3, AIC=2956.33 cat(sprintf(\"Model 2 (Weibull+Weibull): LL=%.2f, k=%d, AIC=%.2f\\n\", ll2, k2, aic2)) #> Model 2 (Weibull+Weibull): LL=-1474.34, k=4, AIC=2956.68 cat(\"Preferred model (lower AIC):\", ifelse(aic1 < aic2, \"Model 1\", \"Model 2\"), \"\\n\") #> Preferred model (lower AIC): Model 1"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"model-assumptions","dir":"Articles","previous_headings":"Model Diagnostics","what":"Model Assumptions","title":"Fitting Series Systems to Data","text":"Review assumptions model makes:","code":"assumptions(m1) #> [1] \"Series system: system fails when any component fails\"             #> [2] \"Component independence: component lifetimes are independent\"      #> [3] \"Non-negative hazard: h_j(t) >= 0 for all j, t > 0\"                #> [4] \"Cumulative hazard diverges: lim(t->Inf) H_sys(t) = Inf\"           #> [5] \"Support is positive reals: t in (0, Inf)\"                         #> [6] \"Observations are independent\"                                     #> [7] \"Censoring indicator: 1=exact, 0=right-censored, -1=left-censored\" #> [8] \"Non-informative censoring\""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"wald-confidence-intervals","dir":"Articles","previous_headings":"Confidence Intervals","what":"Wald Confidence Intervals","title":"Fitting Series Systems to Data","text":"Use variance-covariance matrix vcov() construct Wald-type confidence intervals:","code":"result <- fit(m1)(data_m1, par = c(1.5, 80, 0.02)) #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced #> Warning in log(h_exact): NaNs produced est <- coef(result) se <- sqrt(diag(vcov(result)))  alpha <- 0.05 z <- qnorm(1 - alpha / 2)  ci_lower <- est - z * se ci_upper <- est + z * se  ci_table <- data.frame(     Parameter = c(\"shape\", \"scale\", \"rate\"),     Estimate = est,     SE = se,     Lower = ci_lower,     Upper = ci_upper ) print(ci_table, digits = 4) #>   Parameter  Estimate       SE     Lower     Upper #> 1     shape   2.47432  0.50039  1.493569   3.45507 #> 2     scale 109.13719 11.80866 85.992646 132.28174 #> 3      rate   0.01211  0.00202  0.008153   0.01607"},{"path":"https://queelius.github.io/serieshaz/articles/series-fitting.html","id":"delta-method-for-mtbf","dir":"Articles","previous_headings":"Confidence Intervals","what":"Delta Method for MTBF","title":"Fitting Series Systems to Data","text":"mean time failures (MTBF) function parameters. delta method provides approximate confidence intervals functions parameters.","code":"# For this system, MTBF is not available in closed form, but we can # approximate it numerically and use the delta method par_hat <- coef(result) V <- vcov(result)  # Numerical MTBF estimate via integration of survival function S_fn <- surv(m1)  # Wrap S_fn for integrate() which may pass vectorized t values compute_mtbf <- function(p) {     integrate(function(t) sapply(t, function(ti) S_fn(ti, par = p)),               0, Inf, subdivisions = 1000L)$value }  mtbf <- compute_mtbf(par_hat) cat(\"Estimated MTBF:\", round(mtbf, 2), \"\\n\") #> Estimated MTBF: 53.75  # Delta method: gradient of MTBF w.r.t. parameters eps <- 1e-5 grad_mtbf <- numeric(length(par_hat)) for (k in seq_along(par_hat)) {     par_plus <- par_minus <- par_hat     par_plus[k] <- par_hat[k] + eps     par_minus[k] <- par_hat[k] - eps     grad_mtbf[k] <- (compute_mtbf(par_plus) - compute_mtbf(par_minus)) / (2 * eps) }  se_mtbf <- sqrt(t(grad_mtbf) %*% V %*% grad_mtbf) cat(sprintf(\"MTBF = %.2f +/- %.2f (95%% CI: [%.2f, %.2f])\\n\",             mtbf, 1.96 * se_mtbf, mtbf - 1.96 * se_mtbf, mtbf + 1.96 * se_mtbf)) #> MTBF = 53.75 +/- 4.39 (95% CI: [49.35, 58.14])"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"series-system-theory","dir":"Articles","previous_headings":"","what":"Series System Theory","title":"Mathematical Foundations of Series Systems","text":"series system consists mm independent components, lifetime TjT_j survival function Sj(t)=P(Tj>t)S_j(t) = P(T_j > t). system fails component fails, system lifetime : Tsys=min(T1,…,Tm)T_{sys} = \\min(T_1, \\ldots, T_m) Since components independent: Ssys(t)=P(Tsys>t)=P(T1>t,…,Tm>t)=∏j=1mSj(t)S_{sys}(t) = P(T_{sys} > t) = P(T_1 > t, \\ldots, T_m > t) = \\prod_{j=1}^{m} S_j(t) Taking negative logarithm gives cumulative hazard: Hsys(t)=−logSsys(t)=∑j=1mHj(t)H_{sys}(t) = -\\log S_{sys}(t) = \\sum_{j=1}^{m} H_j(t) Differentiating yields hazard rate: hsys(t)=ddtHsys(t)=∑j=1mhj(t)h_{sys}(t) = \\frac{d}{dt} H_{sys}(t) = \\sum_{j=1}^{m} h_j(t) fundamental result: system hazard sum component hazards.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"key-properties","dir":"Articles","previous_headings":"","what":"Key Properties","title":"Mathematical Foundations of Series Systems","text":"Let’s verify relationships numerically.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"property-1-hazard-sum","dir":"Articles","previous_headings":"Key Properties","what":"Property 1: Hazard Sum","title":"Mathematical Foundations of Series Systems","text":"","code":"library(serieshaz)  sys <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01),     dfr_gompertz(a = 0.001, b = 0.05) ))  h_sys <- hazard(sys) h1 <- component_hazard(sys, 1) h2 <- component_hazard(sys, 2) h3 <- component_hazard(sys, 3)  t_vals <- c(10, 50, 100, 200) for (t0 in t_vals) {     lhs <- h_sys(t0)     rhs <- h1(t0) + h2(t0) + h3(t0)     cat(sprintf(\"t=%3d: h_sys=%.6f, sum h_j=%.6f, diff=%.2e\\n\",                 t0, lhs, rhs, abs(lhs - rhs))) } #> t= 10: h_sys=0.013649, sum h_j=0.013649, diff=0.00e+00 #> t= 50: h_sys=0.032182, sum h_j=0.032182, diff=0.00e+00 #> t=100: h_sys=0.178413, sum h_j=0.178413, diff=0.00e+00 #> t=200: h_sys=22.076466, sum h_j=22.076466, diff=0.00e+00"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"property-2-survival-product","dir":"Articles","previous_headings":"Key Properties","what":"Property 2: Survival Product","title":"Mathematical Foundations of Series Systems","text":"","code":"S_sys <- surv(sys) comp1 <- component(sys, 1) comp2 <- component(sys, 2) comp3 <- component(sys, 3) S1 <- surv(comp1) S2 <- surv(comp2) S3 <- surv(comp3)  for (t0 in t_vals) {     lhs <- S_sys(t0)     rhs <- S1(t0) * S2(t0) * S3(t0)     cat(sprintf(\"t=%3d: S_sys=%.6f, prod S_j=%.6f, diff=%.2e\\n\",                 t0, lhs, rhs, abs(lhs - rhs))) } #> t= 10: S_sys=0.884286, prod S_j=0.884286, diff=1.11e-16 #> t= 50: S_sys=0.377702, prod S_j=0.377702, diff=0.00e+00 #> t=100: S_sys=0.007096, prod S_j=0.007096, diff=0.00e+00 #> t=200: S_sys=0.000000, prod S_j=0.000000, diff=1.52e-210"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"property-3-cumulative-hazard-sum","dir":"Articles","previous_headings":"Key Properties","what":"Property 3: Cumulative Hazard Sum","title":"Mathematical Foundations of Series Systems","text":"","code":"# The system's cumulative hazard is the sum of component cumulative hazards H_sys <- cum_haz(sys) H1 <- cum_haz(comp1) H2 <- cum_haz(comp2) H3 <- cum_haz(comp3)  for (t0 in t_vals) {     lhs <- H_sys(t0)     rhs <- H1(t0) + H2(t0) + H3(t0)     cat(sprintf(\"t=%3d: H_sys=%.6f, sum H_j=%.6f, diff=%.2e\\n\",                 t0, lhs, rhs, abs(lhs - rhs))) } #> t= 10: H_sys=0.122974, sum H_j=0.122974, diff=0.00e+00 #> t= 50: H_sys=0.973650, sum H_j=0.973650, diff=0.00e+00 #> t=100: H_sys=4.948263, sum H_j=4.948263, diff=0.00e+00 #> t=200: H_sys=446.509316, sum H_j=446.509316, diff=0.00e+00"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"property-4-density-formula","dir":"Articles","previous_headings":"Key Properties","what":"Property 4: Density Formula","title":"Mathematical Foundations of Series Systems","text":"system density : fsys(t)=hsys(t)⋅Ssys(t)=[∑j=1mhj(t)]exp[−∑j=1mHj(t)]f_{sys}(t) = h_{sys}(t) \\cdot S_{sys}(t) = \\left[\\sum_{j=1}^m h_j(t)\\right] \\exp\\left[-\\sum_{j=1}^m H_j(t)\\right] density() method manual h(t)⋅S(t)h(t) \\cdot S(t) calculation agree machine precision. Note t=200t = 200, density survival effectively zero — time, combined Weibull + exponential + Gompertz hazard driven cumulative hazard high virtually systems already failed.","code":"f_sys <- density(sys) for (t0 in t_vals) {     from_density <- f_sys(t0)     from_hS <- h_sys(t0) * S_sys(t0)     cat(sprintf(\"t=%3d: f(t)=%.8f, h(t)*S(t)=%.8f, diff=%.2e\\n\",                 t0, from_density, from_hS, abs(from_density - from_hS))) } #> t= 10: f(t)=0.01206938, h(t)*S(t)=0.01206938, diff=0.00e+00 #> t= 50: f(t)=0.01215539, h(t)*S(t)=0.01215539, diff=0.00e+00 #> t=100: f(t)=0.00126597, h(t)*S(t)=0.00126597, diff=0.00e+00 #> t=200: f(t)=0.00000000, h(t)*S(t)=0.00000000, diff=0.00e+00"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"the-parameter-layout","dir":"Articles","previous_headings":"","what":"The Parameter Layout","title":"Mathematical Foundations of Series Systems","text":"series system stores parameters components single flat vector. critical optimization — MLE fitting via optim() requires single parameter vector. optimizer proposes new parameter vector par = c(p1, p2, p3, p4, p5), series system internally slices : component 1 gets par[1:2], component 2 gets par[3], component 3 gets par[4:5].","code":"sys <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),    # 2 params     dfr_exponential(0.05),            # 1 param     dfr_gompertz(a = 0.01, b = 0.1)         # 2 params ))  # Full parameter vector (5 elements) params(sys) #> [1] 2e+00 1e+02 5e-02 1e-02 1e-01  # Layout maps global indices to components param_layout(sys) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 4 5  # Component 1 uses par[1:2], component 2 uses par[3], component 3 uses par[4:5]"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"analytical-vs--numerical-cumulative-hazard","dir":"Articles","previous_headings":"","what":"Analytical vs. Numerical Cumulative Hazard","title":"Mathematical Foundations of Series Systems","text":"cumulative hazard H(t)=∫0th(u)duH(t) = \\int_0^t h(u)\\,du needed survival, CDF, log-likelihood computations. components provide analytical cum_haz_rate, series system computes Hsys(t)=∑jHj(t)H_{sys}(t) = \\sum_j H_j(t) exactly. Otherwise, falls back numerical integration. analytical path faster precise, numerical fallback works correctly valid hazard function.","code":"# All standard distributions provide analytical cumulative hazard sys_analytical <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.05) )) cat(\"Has analytical cum_haz:\", !is.null(sys_analytical$cum_haz_rate), \"\\n\") #> Has analytical cum_haz: TRUE  # A custom dfr_dist without cum_haz_rate forces numerical fallback custom <- dfr_dist(     rate = function(t, par, ...) par[1] * t^(par[1] - 1),     par = c(1.5) ) sys_numerical <- dfr_dist_series(list(     custom,     dfr_exponential(0.05) )) cat(\"Has analytical cum_haz:\", !is.null(sys_numerical$cum_haz_rate), \"\\n\") #> Has analytical cum_haz: FALSE"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"score-and-hessian","dir":"Articles","previous_headings":"","what":"Score and Hessian","title":"Mathematical Foundations of Series Systems","text":"log-likelihood series system observed data (ti,δi)(t_i, \\delta_i) : ℓ(θ)=∑[δiloghsys(ti;θ)−Hsys(ti;θ)]\\ell(\\theta) = \\sum_{} \\left[\\delta_i \\log h_{sys}(t_i; \\theta) - H_{sys}(t_i; \\theta)\\right] δi=1\\delta_i = 1 exact observations δi=0\\delta_i = 0 right-censored observations. score (gradient) Hessian computed via numDeriv: Note distinction: score true parameters generally nonzero finite data (sample deviates population). MLE, score approximately zero definition — ’s first-order optimality condition. Hessian’s negative eigenvalues confirm MLE local maximum. exponential series, sum rates identifiable, individual MLE values may differ true rates even large nn.","code":"sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_exponential(0.2) ))  # Generate some data set.seed(42) samp <- sampler(sys) times <- samp(50) df <- data.frame(t = times, delta = rep(1L, 50))  # Log-likelihood at true parameters ll <- loglik(sys) cat(\"Log-lik at true params:\", ll(df), \"\\n\") #> Log-lik at true params: -128.9726  # Score at TRUE params (generally nonzero with finite n) sc <- score(sys) cat(\"Score at true params:\", sc(df), \"\\n\") #> Score at true params: -62.57988 -62.57988  # Fit to find the MLE, then evaluate score there solver <- fit(sys) mle <- suppressWarnings(solver(df, par = c(0.15, 0.25))) cat(\"MLE:\", coef(mle), \"(sum:\", sum(coef(mle)), \")\\n\") #> MLE: 0.05905292 0.1590529 (sum: 0.2181058 ) cat(\"Score at MLE:\", sc(df, par = coef(mle)), \"\\n\") #> Score at MLE: -2.903142e-05 -2.90364e-05  # Hessian at MLE — eigenvalues should be negative (negative definite) H <- hess_loglik(sys) hess_val <- H(df, par = coef(mle)) cat(\"Hessian eigenvalues:\", eigen(hess_val, symmetric = TRUE)$values, \"\\n\") #> Hessian eigenvalues: -6.62385e-09 -2102.159"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"numerical-verification","dir":"Articles","previous_headings":"Score and Hessian","what":"Numerical Verification","title":"Mathematical Foundations of Series Systems","text":"can verify score indeed gradient log-likelihood using finite differences: numDeriv-based score manual finite-difference approximation agree closely, confirming composed log-likelihood differentiated correctly parameter layout.","code":"par0 <- params(sys) eps <- 1e-5 ll_fn <- loglik(sys) sc_fn <- score(sys)  # Analytical score at par0 score_val <- sc_fn(df, par = par0)  # Finite-difference approximation fd_score <- numeric(length(par0)) for (k in seq_along(par0)) {     par_plus <- par_minus <- par0     par_plus[k] <- par0[k] + eps     par_minus[k] <- par0[k] - eps     fd_score[k] <- (ll_fn(df, par = par_plus) - ll_fn(df, par = par_minus)) / (2 * eps) }  cat(\"Score (numDeriv):   \", score_val, \"\\n\") #> Score (numDeriv):    -62.57988 -62.57988 cat(\"Score (finite diff):\", fd_score, \"\\n\") #> Score (finite diff): -62.57988 -62.57988 cat(\"Max absolute diff:  \", max(abs(score_val - fd_score)), \"\\n\") #> Max absolute diff:   6.891987e-08"},{"path":[]},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"exponential-series-exponentialsum-of-rates","dir":"Articles","previous_headings":"Special Cases","what":"Exponential Series = Exponential(sum of rates)","title":"Mathematical Foundations of Series Systems","text":"components exponential rates λ1,…,λm\\lambda_1, \\ldots, \\lambda_m, system hazard constant: hsys(t)=∑jλjh_{sys}(t) = \\sum_j \\lambda_j. equivalent single exponential rate λ=∑jλj\\lambda = \\sum_j \\lambda_j.","code":"rates <- c(0.1, 0.2, 0.3) sys <- dfr_dist_series(lapply(rates, dfr_exponential)) equiv <- dfr_exponential(sum(rates))  h_sys <- hazard(sys) h_eq  <- hazard(equiv) S_sys <- surv(sys) S_eq  <- surv(equiv)  for (t0 in c(1, 5, 10, 50)) {     cat(sprintf(\"t=%2d: h_sys=%.4f h_eq=%.4f | S_sys=%.6f S_eq=%.6f\\n\",                 t0, h_sys(t0), h_eq(t0), S_sys(t0), S_eq(t0))) } #> t= 1: h_sys=0.6000 h_eq=0.6000 | S_sys=0.548812 S_eq=0.548812 #> t= 5: h_sys=0.6000 h_eq=0.6000 | S_sys=0.049787 S_eq=0.049787 #> t=10: h_sys=0.6000 h_eq=0.6000 | S_sys=0.002479 S_eq=0.002479 #> t=50: h_sys=0.6000 h_eq=0.6000 | S_sys=0.000000 S_eq=0.000000"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"identical-weibull-components","dir":"Articles","previous_headings":"Special Cases","what":"Identical Weibull Components","title":"Mathematical Foundations of Series Systems","text":"mm components Weibull shape kk scale λ\\lambda, system also Weibull shape kk scale λ/m1/k\\lambda / m^{1/k}:","code":"m <- 3 shape <- 2 scale <- 100  sys <- dfr_dist_series(replicate(     m, dfr_weibull(shape = shape, scale = scale), simplify = FALSE )) equiv <- dfr_weibull(shape = shape, scale = scale / m^(1/shape))  S_sys <- surv(sys) S_eq  <- surv(equiv)  for (t0 in c(10, 30, 50)) {     cat(sprintf(\"t=%2d: S_sys=%.6f S_equiv=%.6f diff=%.2e\\n\",                 t0, S_sys(t0), S_eq(t0), abs(S_sys(t0) - S_eq(t0)))) } #> t=10: S_sys=0.970446 S_equiv=0.970446 diff=0.00e+00 #> t=30: S_sys=0.763379 S_equiv=0.763379 diff=1.11e-16 #> t=50: S_sys=0.472367 S_equiv=0.472367 diff=5.55e-17"},{"path":"https://queelius.github.io/serieshaz/articles/series-math.html","id":"single-component-degenerate-case","dir":"Articles","previous_headings":"Special Cases","what":"Single Component (Degenerate Case)","title":"Mathematical Foundations of Series Systems","text":"series system one component equivalent component:","code":"single <- dfr_dist_series(list(dfr_weibull(shape = 2, scale = 100))) direct <- dfr_weibull(shape = 2, scale = 100)  h1 <- hazard(single) h2 <- hazard(direct) S1 <- surv(single) S2 <- surv(direct)  for (t0 in c(10, 50, 100)) {     cat(sprintf(\"t=%3d: h=%.6f/%.6f S=%.6f/%.6f\\n\",                 t0, h1(t0), h2(t0), S1(t0), S2(t0))) } #> t= 10: h=0.002000/0.002000 S=0.990050/0.990050 #> t= 50: h=0.010000/0.010000 S=0.778801/0.778801 #> t=100: h=0.020000/0.020000 S=0.367879/0.367879"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The Problem","title":"Series System Distributions: Overview","text":"Consider server three independent failure modes: Disk — mechanical wear follows Weibull distribution Memory — random bit-flip failures follow exponential distribution Power supply — aging degradation follows Gompertz distribution server fails component fails. series system — like chain breaks weakest link. serieshaz package lets compose failure modes single distribution captures full system behavior.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"what-is-a-series-system","dir":"Articles","previous_headings":"","what":"What Is a Series System?","title":"Series System Distributions: Overview","text":"Given mm independent components hazard functions h1(t),…,hm(t)h_1(t), \\ldots, h_m(t), series system hazard simply sum: hsys(t)=∑j=1mhj(t,θj)h_{sys}(t) = \\sum_{j=1}^{m} h_j(t, \\theta_j) Equivalently, system survival product component survivals: Ssys(t)=∏j=1mSj(t,θj)S_{sys}(t) = \\prod_{j=1}^{m} S_j(t, \\theta_j) follows directly component independence: probability system survives time tt probability components survive time tt.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start","title":"Series System Distributions: Overview","text":"system object 5 parameters total: 2 Weibull + 1 exponential + 2 Gompertz. can see map components:","code":"library(serieshaz)  # Define three failure mode components disk    <- dfr_weibull(shape = 2, scale = 500) memory  <- dfr_exponential(0.001) psu     <- dfr_gompertz(a = 0.0001, b = 0.02)  # Compose into a series system server <- dfr_dist_series(list(disk, memory, psu)) print(server) #> Series system distribution with 3 components #>   Component 1: 2 param(s) [  2, 500] #>   Component 2: 1 param(s) [0.001] #>   Component 3: 2 param(s) [1e-04, 2e-02] #> System hazard: h_sys(t) = sum_j h_j(t, theta_j) #> Survival: S_sys(t) = exp(-H_sys(t)) = prod_j S_j(t, theta_j) param_layout(server) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 4 5"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"everything-from-flexhaz-works","dir":"Articles","previous_headings":"","what":"Everything from flexhaz Works","title":"Series System Distributions: Overview","text":"dfr_dist_series inherits dfr_dist, standard distribution methods work box — special code needed.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"hazard-and-survival","dir":"Articles","previous_headings":"Everything from flexhaz Works","what":"Hazard and Survival","title":"Series System Distributions: Overview","text":"hazard low (≈0.0025\\approx 0.0025) Weibull scale 500 exponential rate 0.001. survival probability ≈84%\\approx 84\\% t=100t = 100 tells us servers still running 100 hours.","code":"h <- hazard(server) S <- surv(server)  # Evaluate at t = 100 hours cat(sprintf(\"System hazard at t=100:  %.6f\\n\", h(100))) #> System hazard at t=100:  0.002539 cat(sprintf(\"System survival at t=100: %.4f\\n\", S(100))) #> System survival at t=100: 0.8420"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"cdf-and-density","dir":"Articles","previous_headings":"Everything from flexhaz Works","what":"CDF and Density","title":"Series System Distributions: Overview","text":"CDF survival sum 1: F(100)+S(100)=1F(100) + S(100) = 1. density f(t)=h(t)⋅S(t)f(t) = h(t) \\cdot S(t) gives instantaneous failure rate weighted probability surviving point.","code":"F_sys <- cdf(server) f_sys <- density(server)  cat(sprintf(\"P(T <= 100) = %.4f\\n\", F_sys(100))) #> P(T <= 100) = 0.1580 cat(sprintf(\"f(100)      = %.6f\\n\", f_sys(100))) #> f(100)      = 0.002138"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"sampling","dir":"Articles","previous_headings":"Everything from flexhaz Works","what":"Sampling","title":"Series System Distributions: Overview","text":"","code":"samp <- sampler(server) set.seed(42) times <- samp(5) times #> [1] 294.9884 302.0998 150.3888 274.2224 236.8369"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"log-likelihood","dir":"Articles","previous_headings":"Everything from flexhaz Works","what":"Log-Likelihood","title":"Series System Distributions: Overview","text":"","code":"ll <- loglik(server) df <- data.frame(t = c(100, 200, 150, 300, 250), delta = c(1, 1, 0, 1, 0)) ll(df) #> [1] -18.97089"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"fitting-mle","dir":"Articles","previous_headings":"Everything from flexhaz Works","what":"Fitting (MLE)","title":"Series System Distributions: Overview","text":"Fitting 5-parameter model (Weibull + exponential + Gompertz) system-level data alone challenging — components’ hazard contributions overlap, making individual parameters hard identify. cleaner demonstration, fit simpler 2-component model: 500 observations mixed-type model (Weibull + exponential), MLE recovers parameters reasonably well. Weibull’s increasing hazard shape distinguishable exponential’s constant hazard, making system identifiable. See vignette(\"series-fitting\") thorough treatment identifiability, censoring, model selection.","code":"# Simpler 2-component model for a clean fit demo fit_model <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.01) )) true_par <- c(2, 100, 0.01)  set.seed(42) fit_samp <- sampler(fit_model) train <- data.frame(t = fit_samp(500), delta = rep(1L, 500))  solver <- fit(fit_model) result <- suppressWarnings(solver(train, par = c(1.5, 80, 0.02)))  cat(\"True parameters:  \", true_par, \"\\n\") #> True parameters:   2 100 0.01 cat(\"Fitted parameters:\", round(coef(result), 3), \"\\n\") #> Fitted parameters: 2.494 112.753 0.013"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"system-introspection","dir":"Articles","previous_headings":"","what":"System Introspection","title":"Series System Distributions: Overview","text":"package provides functions specifically understanding series systems.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"component-count-and-extraction","dir":"Articles","previous_headings":"System Introspection","what":"Component Count and Extraction","title":"Series System Distributions: Overview","text":"","code":"ncomponents(server)  # 3 #> [1] 3  # Extract the Weibull (disk) component disk_comp <- component(server, 1) params(disk_comp) #> [1]   2 500"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"component-hazard-decomposition","dir":"Articles","previous_headings":"System Introspection","what":"Component Hazard Decomposition","title":"Series System Distributions: Overview","text":"t=200t = 200, PSU’s Gompertz degradation dominates system risk (~68%), disk’s Weibull wear-contributing ~20% memory’s constant exponential hazard ~12%. decomposition key advantage series system modeling: reveals failure mode drives system risk given age. Early , constant memory hazard largest contributor, accelerating Gompertz term overtakes around t=150t = 150.","code":"# Get per-component hazard closures h1 <- component_hazard(server, 1)  # disk h2 <- component_hazard(server, 2)  # memory h3 <- component_hazard(server, 3)  # PSU  # At t = 200, which component contributes most? t0 <- 200 hazards <- c(Disk = h1(t0), Memory = h2(t0), PSU = h3(t0)) cat(sprintf(\"Disk:   %.6f (%.1f%%)\\n\", hazards[1], 100 * hazards[1] / sum(hazards))) #> Disk:   0.001600 (19.9%) cat(sprintf(\"Memory: %.6f (%.1f%%)\\n\", hazards[2], 100 * hazards[2] / sum(hazards))) #> Memory: 0.001000 (12.4%) cat(sprintf(\"PSU:    %.6f (%.1f%%)\\n\", hazards[3], 100 * hazards[3] / sum(hazards))) #> PSU:    0.005460 (67.7%) cat(sprintf(\"System: %.6f\\n\", h(t0))) #> System: 0.008060 cat(sprintf(\"Sum:    %.6f (matches system)\\n\", sum(hazards))) #> Sum:    0.008060 (matches system)"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"failure-attribution-via-sampling","dir":"Articles","previous_headings":"System Introspection","what":"Failure Attribution via Sampling","title":"Series System Distributions: Overview","text":"","code":"set.seed(42) mat <- sample_components(server, n = 10000)  # System lifetime = min across components t_sys <- apply(mat, 1, min)  # Which component caused each failure? failing <- apply(mat, 1, which.min) cat(\"Failure proportions:\\n\") #> Failure proportions: round(table(failing) / length(failing), 3) #> failing #>     1     2     3  #> 0.182 0.200 0.618"},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"the-ecosystem","dir":"Articles","previous_headings":"","what":"The Ecosystem","title":"Series System Distributions: Overview","text":"serieshaz builds three packages: algebraic.dist — Base distribution generics: hazard, surv, cdf, inv_cdf, sampler, params likelihood.model — Statistical inference: loglik, score, hess_loglik, fit, assumptions flexhaz — DFR distributions: dfr_dist, dfr_exponential, dfr_weibull, dfr_gompertz, dfr_loglogistic inheritance chain : dfr_dist_series → dfr_dist → likelihood_model → univariate_dist → dist. Every method defined level chain works automatically series systems.","code":""},{"path":"https://queelius.github.io/serieshaz/articles/series-overview.html","id":"where-to-go-next","dir":"Articles","previous_headings":"","what":"Where to Go Next","title":"Series System Distributions: Overview","text":"vignette(\"series-math\") — Mathematical foundations derivations vignette(\"series-fitting\") — MLE fitting workflows, identifiability, diagnostics vignette(\"series-advanced\") — Nested systems, custom components, failure attribution","code":""},{"path":"https://queelius.github.io/serieshaz/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Towell. Author, maintainer.","code":""},{"path":"https://queelius.github.io/serieshaz/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Towell (2026). serieshaz: Series System Distributions Dynamic Failure Rate Components. R package version 0.1.0, https://queelius.github.io/serieshaz/, https://github.com/queelius/serieshaz.","code":"@Manual{,   title = {serieshaz: Series System Distributions from Dynamic Failure Rate Components},   author = {Alexander Towell},   year = {2026},   note = {R package version 0.1.0,     https://queelius.github.io/serieshaz/},   url = {https://github.com/queelius/serieshaz}, }"},{"path":"https://queelius.github.io/serieshaz/index.html","id":"serieshaz","dir":"","previous_headings":"","what":"Series System Distributions from Dynamic Failure Rate Components","title":"Series System Distributions from Dynamic Failure Rate Components","text":"Series System Distributions Dynamic Failure Rate Components serieshaz composes multiple dfr_dist objects series system distribution. series system fails component fails, system hazard sum component hazards: hsys(t)=∑j=1mhj(t,θj)h_{sys}(t) = \\sum_{j=1}^{m} h_j(t, \\theta_j) resulting object inherits dfr_dist, existing methods — hazard, survival, CDF, density, sampling, log-likelihood, MLE fitting — work automatically.","code":""},{"path":"https://queelius.github.io/serieshaz/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Series System Distributions from Dynamic Failure Rate Components","text":"Install r-universe:","code":"install.packages(\"serieshaz\", repos = \"https://queelius.r-universe.dev\")"},{"path":"https://queelius.github.io/serieshaz/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Series System Distributions from Dynamic Failure Rate Components","text":"","code":"library(serieshaz)  # Three-component server with different failure modes server <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 500),     # disk wear-out     dfr_exponential(0.001),            # random memory failure     dfr_gompertz(a = 0.0001, b = 0.02)       # PSU degradation ))  # Evaluate system hazard and survival h <- hazard(server) S <- surv(server)  h(100)   # system hazard at t = 100 #> [1] 0.002538906 S(100)   # probability of surviving past t = 100 #> [1] 0.8420252 # Sample system lifetimes set.seed(42) samp <- sampler(server) times <- samp(5) times #> [1] 294.9884 302.0998 150.3888 274.2224 236.8369 # Introspect: which component contributes most at t = 200? for (j in 1:ncomponents(server)) {     hj <- component_hazard(server, j)     cat(sprintf(\"Component %d hazard at t=200: %.6f\\n\", j, hj(200))) } #> Component 1 hazard at t=200: 0.001600 #> Component 2 hazard at t=200: 0.001000 #> Component 3 hazard at t=200: 0.005460"},{"path":"https://queelius.github.io/serieshaz/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Series System Distributions from Dynamic Failure Rate Components","text":"Composition: Combine dfr_dist objects (Weibull, exponential, Gompertz, log-logistic, custom) series systems Full interface: distribution methods (hazard, survival, CDF, density, quantile, sampling) work box MLE fitting: Fit series system parameters observed failure data fit() Introspection: ncomponents(), component(), param_layout(), component_hazard(), sample_components() Nesting: Series systems can nested components larger series systems Analytical cumulative hazard: components provide closed-form cumulative hazard, series system ","code":""},{"path":"https://queelius.github.io/serieshaz/index.html","id":"ecosystem","dir":"","previous_headings":"","what":"Ecosystem","title":"Series System Distributions from Dynamic Failure Rate Components","text":"serieshaz builds : algebraic.dist — Base distribution generics likelihood.model — Statistical inference generics flexhaz — Dynamic failure rate distributions","code":""},{"path":"https://queelius.github.io/serieshaz/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Series System Distributions from Dynamic Failure Rate Components","text":"vignette(\"series-overview\") — Package overview quick start vignette(\"series-math\") — Mathematical foundations vignette(\"series-fitting\") — MLE fitting inference vignette(\"series-advanced\") — Advanced composition patterns","code":""},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Assumptions for series system distributions — assumptions.dfr_dist_series","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"Returns statistical structural assumptions underlying series system model, important validity MLE-based inference.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"","code":"# S3 method for class 'dfr_dist_series' assumptions(model, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"model dfr_dist_series object. ... Additional arguments (unused).","code":""},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"Character vector model assumptions.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"assumptions returned : Series structure: system fails component fails (weakest-link model) Component independence: Component lifetimes statistically independent Non-negative hazard: component hazard satisfies \\(h_j(t) \\geq 0\\) \\(t > 0\\) Proper distribution: cumulative hazard diverges, ensuring \\(S_{sys}(t) \\0\\) \\(t \\\\infty\\) Positive support: time domain \\((0, \\infty)\\) Independent observations: observed lifetimes independent Censoring convention: delta = 1 exact, 0 right-censored, -1 left-censored Non-informative censoring: censoring mechanism carries information failure process assumptions required MLE fitting procedure (fit) produce valid estimates. Violation component independence, particular, invalidates hazard-sum property defines series systems.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/assumptions.dfr_dist_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assumptions for series system distributions — assumptions.dfr_dist_series","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_weibull(shape = 2, scale = 100) )) assumptions(sys) #> [1] \"Series system: system fails when any component fails\"             #> [2] \"Component independence: component lifetimes are independent\"      #> [3] \"Non-negative hazard: h_j(t) >= 0 for all j, t > 0\"                #> [4] \"Cumulative hazard diverges: lim(t->Inf) H_sys(t) = Inf\"           #> [5] \"Support is positive reals: t in (0, Inf)\"                         #> [6] \"Observations are independent\"                                     #> [7] \"Censoring indicator: 1=exact, 0=right-censored, -1=left-censored\" #> [8] \"Non-informative censoring\"                                        # }"},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a component from a system — component","title":"Extract a component from a system — component","text":"Extracts component j series system standalone dfr_dist object, parameters set current values system's parameter vector (via layout).","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a component from a system — component","text":"","code":"component(x, j, ...)  # S3 method for class 'dfr_dist_series' component(x, j, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a component from a system — component","text":"x system object (e.g., dfr_dist_series). j Component index (integer, 1 <= j <= ncomponents(x)). ... Additional arguments passed methods.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a component from a system — component","text":"dfr_dist object component j.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract a component from a system — component","text":"returned component object copy original component par field updated reflect current system-level parameter vector. means can evaluate extracted component's hazard, survival, etc. directly: Changes extracted component propagate back original series system.","code":"comp1 <- component(sys, 1) h1 <- hazard(comp1) h1(10)  # evaluates using parameters from the system"},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Extract a component from a system — component","text":"component(dfr_dist_series): Extract component j standalone dfr_dist current parameters series system's parameter vector.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/component.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a component from a system — component","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.05) ))  # Extract the Weibull component wb <- component(sys, 1) params(wb)  # c(2, 100) #> [1]   2 100  # Evaluate its hazard independently h_wb <- hazard(wb) h_wb(50) #> [1] 0.01 # }"},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the hazard function for a specific component — component_hazard","title":"Get the hazard function for a specific component — component_hazard","text":"Returns closure computes hazard rate component j series system. Useful plotting hazard decompositions understanding component's contribution system risk.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the hazard function for a specific component — component_hazard","text":"","code":"component_hazard(x, j, ...)  # S3 method for class 'dfr_dist_series' component_hazard(x, j, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the hazard function for a specific component — component_hazard","text":"x system object (e.g., dfr_dist_series). j Component index (integer, 1 <= j <= ncomponents(x)). ... Additional arguments passed methods.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the hazard function for a specific component — component_hazard","text":"closure function(t, par = NULL, ...) evaluates component j's hazard rate. par NULL, component's default parameters (system) used.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the hazard function for a specific component — component_hazard","text":"returned closure evaluates \\(h_j(t, \\theta_j)\\) component j. par argument accepts component-local parameters (full system parameter vector). useful : Plotting individual hazard contributions Verifying \\(\\sum_j h_j(t) = h_{sys}(t)\\) Sensitivity analysis single component","code":""},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Get the hazard function for a specific component — component_hazard","text":"component_hazard(dfr_dist_series): Hazard closure component j series system. Returns function(t, par_j = NULL, ...) par_j component-local parameters.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/component_hazard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the hazard function for a specific component — component_hazard","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_exponential(0.2) ))  h1 <- component_hazard(sys, 1) h2 <- component_hazard(sys, 2) h_sys <- hazard(sys)  # Verify hazard sum property t <- 10 h1(t) + h2(t)  # 0.3 #> [1] 0.3 h_sys(t)        # 0.3 (same!) #> [1] 0.3 # }"},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Series System Distribution from DFR Components — dfr_dist_series","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"Composes m dfr_dist component distributions series system distribution. series system fails component fails, system hazard sum component hazards: \\(h_{sys}(t) = \\sum_j h_j(t)\\).","code":""},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"","code":"dfr_dist_series(components, par = NULL, n_par = NULL)"},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"components list dfr_dist objects representing system components. par Optional concatenated parameter vector \\(\\theta = (\\theta_1, \\ldots, \\theta_m)\\). NULL, parameters concatenated component objects. n_par Optional integer vector giving number parameters per component. Inferred component par supplied; required component NULL parameters.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"dfr_dist_series object (inherits dfr_dist). Extra fields: $components, $layout, $m, $n_par.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"resulting object inherits dfr_dist, existing methods (hazard, survival, CDF, density, sampling, log-likelihood, MLE fitting) work automatically. Parameter layout: Parameters stored single concatenated vector. $layout field maps global indices component indices. example, component 1 2 parameters component 2 1, layout = list(1:2, 3). Analytical cumulative hazard: components provide cum_haz_rate, series system gets analytical \\(H_{sys}(t) = \\sum_j H_j(t)\\). Otherwise, falls back numerical integration. Score Hessian: Fall back numDeriv::grad numDeriv::hessian (correct) composed log-likelihood. Identifiability: Exponential series systems identifiable system-level data alone — sum rates identifiable. fitting data, check sum(coef(result)) rather individual rate parameters. Mixed-type series systems (e.g., Weibull + Gompertz) generally identifiable components different hazard shapes. Nested series: dfr_dist_series dfr_dist, can used component another series system. resulting nested system's hazard sum leaf-component hazards. Class hierarchy: dfr_dist_series inherits dfr_dist -> likelihood_model -> univariate_dist -> dist. methods parent classes work automatically.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/dfr_dist_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Series System Distribution from DFR Components — dfr_dist_series","text":"","code":"# \\donttest{ library(flexhaz)  # --- Basic exponential series --- # Three exponential components -> equivalent to single exponential sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_exponential(0.2),     dfr_exponential(0.3) )) # System hazard = 0.6 (constant) h <- hazard(sys) h(10)  # 0.6 #> [1] 0.6  # System survival at t = 5 S <- surv(sys) S(5)   # exp(-0.6 * 5) #> [1] 0.04978707  # --- Mixed Weibull + Gompertz series --- sys2 <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_gompertz(a = 0.01, b = 0.1) )) h2 <- hazard(sys2) h2(50)  # sum of Weibull and Gompertz hazards at t=50 #> [1] 1.494132  # --- Nested series --- subsystem <- dfr_dist_series(list(     dfr_exponential(0.05),     dfr_exponential(0.10) )) full_system <- dfr_dist_series(list(     subsystem,     dfr_weibull(shape = 2, scale = 200) ))  # --- Fitting workflow --- solver <- fit(sys) # result <- solver(df, par = c(0.1, 0.2, 0.3)) # coef(result)   # fitted parameters # vcov(result)   # variance-covariance matrix # logLik(result) # maximized log-likelihood # }"},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"Returns TRUE x inherits \"dfr_dist_series\", FALSE otherwise.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"","code":"is_dfr_dist_series(x)"},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"x Object test.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"Logical scalar.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"Since dfr_dist_series inherits dfr_dist, object passes is_dfr_dist_series() also pass is_dfr_dist(). Use function need distinguish series systems ordinary dfr_dist objects.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/is_dfr_dist_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test whether an object is a dfr_dist_series — is_dfr_dist_series","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_exponential(0.2) )) is_dfr_dist_series(sys)  # TRUE #> [1] TRUE is_dfr_dist(sys)         # also TRUE (inherits dfr_dist) #> [1] TRUE  single <- dfr_exponential(0.5) is_dfr_dist_series(single)  # FALSE #> [1] FALSE is_dfr_dist(single)         # TRUE #> [1] TRUE  is_dfr_dist_series(42)  # FALSE #> [1] FALSE # }"},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of components in a system — ncomponents","title":"Get the number of components in a system — ncomponents","text":"Returns number components \\(m\\) series system, corresponding number terms \\(h_{sys}(t) = \\sum_{j=1}^{m} h_j(t)\\).","code":""},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of components in a system — ncomponents","text":"","code":"ncomponents(x, ...)  # S3 method for class 'dfr_dist_series' ncomponents(x, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of components in a system — ncomponents","text":"x system object (e.g., dfr_dist_series). ... Additional arguments passed methods.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of components in a system — ncomponents","text":"Integer, number components.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the number of components in a system — ncomponents","text":"dfr_dist_series object created list m components, simply returns m. useful programmatically iterating components, e.g., plotting hazard decompositions computing failure attribution.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Get the number of components in a system — ncomponents","text":"ncomponents(dfr_dist_series): Number components series system.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/ncomponents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of components in a system — ncomponents","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_weibull(shape = 2, scale = 100),     dfr_gompertz(a = 0.01, b = 0.05) )) ncomponents(sys)  # 3 #> [1] 3 # }"},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the parameter layout for a system — param_layout","title":"Get the parameter layout for a system — param_layout","text":"Returns mapping global (flat) parameter indices per-component parameter indices, enabling series system distribute single parameter vector across components.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the parameter layout for a system — param_layout","text":"","code":"param_layout(x, ...)  # S3 method for class 'dfr_dist_series' param_layout(x, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the parameter layout for a system — param_layout","text":"x system object (e.g., dfr_dist_series). ... Additional arguments passed methods.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the parameter layout for a system — param_layout","text":"list integer vectors, one per component, containing global parameter indices.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the parameter layout for a system — param_layout","text":"Parameters across components stored single concatenated vector \\(\\theta = (\\theta_1, \\ldots, \\theta_m)\\). layout maps global indices back component. example, : Component 1: Weibull (shape, scale) — 2 parameters Component 2: Exponential (rate) — 1 parameter Component 3: Gompertz (, b) — 2 parameters layout list(1:2, 3, 4:5), global parameter vector c(shape1, scale1, rate2, a3, b3) gets sliced par[1:2] component 1, par[3] component 2, par[4:5] component 3. design enables standard optimizers work flat vector series system internally distributes parameters correct components.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Get the parameter layout for a system — param_layout","text":"param_layout(dfr_dist_series): Parameter index mapping series system.","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/param_layout.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the parameter layout for a system — param_layout","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_weibull(shape = 2, scale = 100),     dfr_exponential(0.05),     dfr_gompertz(a = 0.01, b = 0.1) )) param_layout(sys) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 4 5 #>  # list(1:2, 3, 4:5) # }"},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for series system distributions — print.dfr_dist_series","title":"Print method for series system distributions — print.dfr_dist_series","text":"Displays human-readable summary series system distribution, including number components, per-component parameter counts values, system hazard/survival formulas.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for series system distributions — print.dfr_dist_series","text":"","code":"# S3 method for class 'dfr_dist_series' print(x, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for series system distributions — print.dfr_dist_series","text":"x dfr_dist_series object. ... Additional arguments (unused).","code":""},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for series system distributions — print.dfr_dist_series","text":"Invisibly returns x.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print method for series system distributions — print.dfr_dist_series","text":"output includes: Header number components One line per component showing parameter count current parameter values (\"unknown\" parameters NULL) system hazard formula: \\(h_{sys}(t) = \\sum_j h_j(t, \\theta_j)\\) system survival formula: \\(S_{sys}(t) = \\prod_j S_j(t, \\theta_j)\\)","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/print.dfr_dist_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for series system distributions — print.dfr_dist_series","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_weibull(shape = 2, scale = 100) )) print(sys) #> Series system distribution with 2 components #>   Component 1: 1 param(s) [0.1] #>   Component 2: 2 param(s) [  2, 100] #> System hazard: h_sys(t) = sum_j h_j(t, theta_j) #> Survival: S_sys(t) = exp(-H_sys(t)) = prod_j S_j(t, theta_j) # Series system distribution with 2 components #   Component 1: 1 param(s) [0.1] #   Component 2: 2 param(s) [2, 100] # System hazard: h_sys(t) = sum_j h_j(t, theta_j) # Survival: S_sys(t) = exp(-H_sys(t)) = prod_j S_j(t, theta_j) # }"},{"path":"https://queelius.github.io/serieshaz/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. algebraic.dist cdf, hazard, inv_cdf, params, sampler, surv flexhaz cum_haz, dfr_dist, dfr_exponential, dfr_gompertz, dfr_loglogistic, dfr_weibull, is_dfr_dist generics fit likelihood.model assumptions, hess_loglik, loglik, score","code":""},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample component lifetimes from a system — sample_components","title":"Sample component lifetimes from a system — sample_components","text":"Generates \\(n \\times m\\) matrix column \\(j\\) contains independent samples component \\(j\\)'s lifetime distribution. system lifetime row-wise minimum.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample component lifetimes from a system — sample_components","text":"","code":"sample_components(x, n, ...)  # S3 method for class 'dfr_dist_series' sample_components(x, n, par = NULL, ...)"},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample component lifetimes from a system — sample_components","text":"x system object (e.g., dfr_dist_series). n Number samples (rows). ... Additional arguments passed methods. par Optional parameter vector override.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample component lifetimes from a system — sample_components","text":"\\(n \\times m\\) numeric matrix component lifetimes, columns named comp1, comp2, etc.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample component lifetimes from a system — sample_components","text":"column sampled independently using component's sampler. Since series system fails component fails, system lifetime observation : failing component observation can identified via: enables failure attribution analysis: proportion system failures caused component?","code":"t_sys <- apply(mat, 1, min) failing <- apply(mat, 1, which.min)"},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Sample component lifetimes from a system — sample_components","text":"sample_components(dfr_dist_series): Sample component lifetimes series system. Returns n x m matrix column j holds samples component j. system lifetime apply(mat, 1, min).","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/sample_components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample component lifetimes from a system — sample_components","text":"","code":"# \\donttest{ library(flexhaz)  sys <- dfr_dist_series(list(     dfr_exponential(0.1),     dfr_exponential(0.2),     dfr_exponential(0.3) ))  set.seed(42) mat <- sample_components(sys, n = 1000) dim(mat)  # 1000 x 3 #> [1] 1000    3  # System lifetimes t_sys <- apply(mat, 1, min)  # Which component caused each failure? failing <- apply(mat, 1, which.min) table(failing) / 1000 #> failing #>     1     2     3  #> 0.173 0.345 0.482  # Proportions ~= c(1/6, 2/6, 3/6) for rates (0.1, 0.2, 0.3) # }"},{"path":"https://queelius.github.io/serieshaz/reference/serieshaz-package.html","id":null,"dir":"Reference","previous_headings":"","what":"serieshaz: Series System Distributions from Dynamic Failure Rate Components — serieshaz-package","title":"serieshaz: Series System Distributions from Dynamic Failure Rate Components — serieshaz-package","text":"Compose multiple dynamic failure rate (DFR) distributions series system distributions. series system fails component fails, giving system hazard equal sum component hazards. resulting object inherits 'dfr_dist' existing methods (hazard, survival, CDF, density, sampling, MLE fitting) work automatically.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/serieshaz-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"serieshaz: Series System Distributions from Dynamic Failure Rate Components — serieshaz-package","text":"serieshaz package composes multiple dynamic failure rate (dfr_dist) distributions series system distribution. series system fails component fails, system hazard sum component hazards: $$h_{sys}(t) = \\sum_{j=1}^{m} h_j(t, \\theta_j)$$ system survival product component survivals: $$S_{sys}(t) = \\prod_{j=1}^{m} S_j(t, \\theta_j)$$ series system object inherits dfr_dist, turn inherits likelihood_model, univariate_dist, dist. means existing methods — hazard, survival, CDF, density, quantile function, sampling, log-likelihood, score, Hessian, MLE fitting — work automatically series systems without reimplementation. Parameters across components stored single flat vector, layout maps global indices per-component indices. design enables standard optimizers (e.g., optim) work directly concatenated parameter vector.","code":""},{"path":"https://queelius.github.io/serieshaz/reference/serieshaz-package.html","id":"package-functions","dir":"Reference","previous_headings":"","what":"Package functions","title":"serieshaz: Series System Distributions from Dynamic Failure Rate Components — serieshaz-package","text":"dfr_dist_series Constructor: compose components series system is_dfr_dist_series Type predicate ncomponents Number components component Extract single component param_layout Parameter index mapping component_hazard Component-level hazard closure sample_components Sample component lifetimes","code":""},{"path":[]},{"path":"https://queelius.github.io/serieshaz/reference/serieshaz-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"serieshaz: Series System Distributions from Dynamic Failure Rate Components — serieshaz-package","text":"Maintainer: Alexander Towell lex@metafunctor.com","code":""},{"path":"https://queelius.github.io/serieshaz/news/index.html","id":"serieshaz-010","dir":"Changelog","previous_headings":"","what":"serieshaz 0.1.0","title":"serieshaz 0.1.0","text":"Initial release.","code":""},{"path":"https://queelius.github.io/serieshaz/news/index.html","id":"features-0-1-0","dir":"Changelog","previous_headings":"","what":"Features","title":"serieshaz 0.1.0","text":"dfr_dist_series() constructor composes multiple dfr_dist components series system distribution system hazard sum component hazards. Full inheritance dfr_dist: hazard, survival, CDF, density, quantile, sampling, log-likelihood, score, Hessian, MLE fitting work automatically. Analytical cumulative hazard components provide cum_haz_rate; numerical integration fallback otherwise. Series-specific introspection: ncomponents(), component(), param_layout(), component_hazard(), sample_components(). Nested series system support (dfr_dist_series can component another series system). Four vignettes: overview, mathematical foundations, MLE fitting workflows, advanced composition.","code":""}]
